<html>
	<head>
	<title>PHP5.2自5.6新特性 - Jaylee</title>
	<meta content='width=device-width, initial-scale=1.0, user-scalable=no' name='viewport'>
<meta content='text/html; charset=utf-8' http-equiv='content-type' />

<link href='/images/fav.png' rel='shortcut icon'>
<link href='/stylesheets/style.css' rel='stylesheet' type='text/css' />
<link href='/stylesheets/syntax.css' rel='stylesheet' type='text/css' />
<link href='/stylesheets/responsive.css' rel='stylesheet' type='text/css' />
<link href="/stylesheets/nprogress.css" rel='stylesheet' type='text/css' />

<link href="/feed.xml" rel="alternate" type="application/rss+xml">

<script src='/javascripts/jquery.js' type='text/javascript'></script>
<script src='/javascripts/nprogress.js' type='text/javascript'></script>

<script src='/javascripts/app.js' type='text/javascript'></script>
<script>var duoshuoQuery = {short_name:"jaylee"};</script>
	</head>
	<body>

		<header>
<a id="go-back-home" href="/"><img src="/images/scribble.png" alt="Home" width="53" height="59"></a>
<p>Jaylee</p>
<p>Do have faith in what you're doing.</p>
</header>


		<div id='container'>
			
			<div class="block">
  
    <a target="_top" class="main" href="/about.html">About</a>
  
    <a target="_top" class="main" href="/">Blog</a>
  
    <a target="_top" class="main" href="/feed.xml">Feed</a>
  
    <a target="_blank" class="main" href="https://github.com/sjclijie">GitHub</a>
  
</div>

			<section class="paging">
  
    <div class="left">
      <a href="/php-trait-details/" pjax=true>
        ‹
      </a>
    </div>
  
  
    <div class="right">
      <a href="/comprehensive-course-for-awk/" pjax=true>
        ›
      </a>
    </div>
  
</section>


			<div class="content">
				<section class='post'>
					<h1>
						PHP5.2自5.6新特性
						<div class='date'>26 Oct 2014</div>
					</h1>
					<p>截至目前( 2014.10 )，PHP的最新稳定版本是PHP5.6，但有差不多一半的用户仍然在使用已经不在维护的PHP5.2，其余的一半用户在使用PHP5.3 ( PHP5.3也于2014年9月停止支持 )。因为PHP那 “ 集百家之长 ”的蛋疼语法，加上社区氛围不太好，许多人对新版本，新特性并无兴趣。</p>

<hr>

<p><strong>本文会介绍自PHP5.2起，直到PHP5.6中增加的新特性。</strong></p>

<ul>
<li>PHP5.2以前：autoload, PDO和MySQLi, 类型约束</li>
<li>PHP5.2：JSON的支持</li>
<li>PHP5.3：弃用的功能，匿名函数，新增魔术方法，命名空间，延迟静态绑定，Heredoc和Nowdoc，const，三元运算符，Phar</li>
<li>PHP5.4：Short Open Tag，数组简写形式，Traits，内置web服务器，细节修改</li>
<li>PHP5.5：yield，list()可用于foreach循环，细节修改</li>
<li>PHP5.6：常量增强，可变函数参数，命名空间增强</li>
</ul>

<hr>

<blockquote>
<p>PHP5.2以前</p>

<p>2006年前（顺便介绍一下PHP5.2已经出现但是值得介绍的特性）</p>
</blockquote>

<p><strong>autoload</strong></p>

<p>大家应该都知道__autoload()函数，如果定义了该函数，那么当在代码中使用了一个未定义的类的时候，该函数就会被调用，你可以在该函数中加载相应的类实现文件，如：</p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>

    <span class="k">function</span> <span class="nf">__autoload</span><span class="p">(</span><span class="nv">$className</span><span class="p">){</span>
        <span class="k">require_once</span> <span class="nv">$className</span><span class="o">.</span><span class="s2">&quot;.class.php&quot;</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nv">$foo</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Foo</span><span class="p">();</span>

<span class="cp">?&gt;</span><span class="x"></span>
</code></pre></div>
<p>这样，在执行new操作的时候，会在当前目录下寻找Foo.class.php这个文件，并加载进来。</p>

<p>但该函数已经不建议使用，原因是一个项目中仅能有一个这样的_<em>autoload()函数，因为PHP不允许函数重名。但当你用到一些类库的时候，难免会出现多个autoload函数的需要，于是spl</em>autoload_register()取而代之：</p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>    

    <span class="k">function</span> <span class="nf">autoloadModel</span><span class="p">(</span><span class="nv">$className</span><span class="p">){</span>
        <span class="nv">$filename</span> <span class="o">=</span> <span class="s2">&quot;models/&quot;</span><span class="o">.</span><span class="nv">$className</span><span class="o">.</span><span class="s2">&quot;.php&quot;</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span> <span class="nb">file_exists</span><span class="p">(</span><span class="nv">$filename</span><span class="p">)</span> <span class="p">){</span>
            <span class="k">require_once</span> <span class="nv">$filename</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">function</span> <span class="nf">autoloadController</span><span class="p">(</span><span class="nv">$className</span><span class="p">){</span>
        <span class="nv">$filename</span> <span class="o">=</span> <span class="s2">&quot;controller/&quot;</span><span class="o">.</span><span class="nv">$className</span><span class="o">.</span><span class="s2">&quot;.php&quot;</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span> <span class="nb">file_exists</span><span class="p">(</span><span class="nv">$filename</span><span class="p">)</span> <span class="p">){</span>
            <span class="k">require_once</span> <span class="nv">$filename</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nb">spl_autoload_register</span><span class="p">(</span><span class="s2">&quot;autoloadModel&quot;</span><span class="p">);</span>
    <span class="nb">spl_autoload_register</span><span class="p">(</span><span class="s2">&quot;autoloadController&quot;</span><span class="p">);</span>

<span class="cp">?&gt;</span><span class="x"></span>
</code></pre></div>
<p>spl<em>autoload</em>register()会将一个函数注册到autoload函数列表中，当出现未定义的类的时候，SPL会按照注册的顺序逐个调用被注册的autoload函数，这意味着你可以使用spl<em>autoload</em>register注册多个autoload函数。</p>

<p><strong>PDO和MySQLi</strong></p>

<p>PDO即PHP Data Object , PHP数据对象，这是PHP的新式数据库访问接口。</p>

<p>按照传统的风格，访问MySQL数据库应该是这个样子：</p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>

    <span class="nv">$conn</span> <span class="o">=</span> <span class="nb">mysql_connect</span><span class="p">(</span><span class="s2">&quot;localhost&quot;</span><span class="p">,</span><span class="s2">&quot;user&quot;</span><span class="p">,</span><span class="s2">&quot;passwd&quot;</span><span class="p">)</span> <span class="k">or</span> <span class="k">die</span><span class="p">(</span><span class="s2">&quot;Connection failed&quot;</span><span class="p">);</span>

    <span class="nb">mysql_select_db</span><span class="p">(</span><span class="s2">&quot;test&quot;</span><span class="p">);</span>

    <span class="nv">$type</span> <span class="o">=</span> <span class="nv">$_POST</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">];</span>

    <span class="nv">$sql</span> <span class="o">=</span> <span class="s2">&quot;select * from `table` where `type` = </span><span class="si">{</span><span class="nv">$type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">;</span>

    <span class="nv">$result</span> <span class="o">=</span> <span class="nb">mysql_query</span><span class="p">(</span><span class="nv">$sql</span><span class="p">,</span> <span class="nv">$conn</span><span class="p">);</span>

    <span class="k">while</span><span class="p">(</span><span class="nv">$row</span> <span class="o">=</span> <span class="nb">mysql_fetch_assoc</span><span class="p">(</span><span class="nv">$result</span><span class="p">)){</span>
        <span class="nb">var_dump</span><span class="p">(</span><span class="nv">$row</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nb">mysql_free_result</span><span class="p">(</span><span class="nv">$result</span><span class="p">);</span>

    <span class="nb">mysql_close</span><span class="p">(</span><span class="nv">$conn</span><span class="p">);</span>

<span class="cp">?&gt;</span><span class="x"></span>
</code></pre></div>
<p>为了能让代码实现与数据库无关，即同一段代码适用于多种数据库（例如以上代码仅适用于MySQL），PHP官方设计了PDO.</p>

<p>除此之外，PDO还提供了更多的功能，比如：</p>

<ul>
<li>面对对象风格接口</li>
<li>SQL预编译，占位符语法</li>
<li>更高的执行效率，作为官方推荐，有特别的性能优化</li>
<li>支持大部分SQL数据库，更换数据库无需改动代码</li>
</ul>

<p>上面的代码用PDO实现将会是这个样子：</p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>

    <span class="k">try</span> <span class="p">{</span>

        <span class="nv">$dsn</span> <span class="o">=</span> <span class="s2">&quot;mysql:host=localhost;dbname=test&quot;</span><span class="p">;</span>

        <span class="nv">$conn</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">PDO</span><span class="p">(</span><span class="nv">$dsn</span><span class="p">,</span> <span class="s2">&quot;user&quot;</span><span class="p">,</span> <span class="s2">&quot;passwd&quot;</span><span class="p">);</span>

        <span class="nv">$sql</span> <span class="o">=</span> <span class="s2">&quot;select * from user where type = :type &quot;</span><span class="p">;</span>

        <span class="nv">$stmt</span> <span class="o">=</span> <span class="nv">$conn</span><span class="o">-&gt;</span><span class="na">prepare</span><span class="p">(</span><span class="nv">$sql</span><span class="p">);</span>

        <span class="nv">$stmt</span><span class="o">-&gt;</span><span class="na">bindParams</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">,</span><span class="nv">$_POST</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]);</span>

        <span class="nv">$stmt</span><span class="o">-&gt;</span><span class="na">execute</span><span class="p">();</span>

        <span class="nv">$stmt</span><span class="o">-&gt;</span><span class="na">fetchAll</span><span class="p">(</span><span class="nx">PDO</span><span class="o">::</span><span class="na">FETCH_ASSOC</span><span class="p">);</span>

    <span class="p">}</span><span class="k">catch</span><span class="p">(</span><span class="nx">PDOException</span> <span class="nv">$e</span><span class="p">){</span>

        <span class="k">echo</span> <span class="nv">$e</span><span class="o">-&gt;</span><span class="na">getMessage</span><span class="p">();</span>
    <span class="p">}</span>

<span class="cp">?&gt;</span><span class="x"></span>
</code></pre></div>
<p>PDO是官方推荐的，更为通用的数据库访问方式，如果你没有特殊的需求，那么最好学习和使用POD，但如果你需要使用MySQL所特有的高级功能，那么你可能需要尝试一下MySQLi，因为PDO为了能够同时在多种数据库上使用，不会包含那些MySQL独有的功能。</p>

<p><strong>类型约束</strong></p>

<p>通过类型约束可以限制参数的类型，不过这一机制并不完善，仅适用于对象，接口，callable，以及array，不适用于string和int，如果参数类型不匹配，则会产生一个fatal error.</p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>

    <span class="k">function</span> <span class="nf">test</span><span class="p">(</span><span class="nx">callable</span> <span class="nv">$callable</span><span class="p">,</span> <span class="k">array</span> <span class="nv">$arr</span><span class="p">,</span> <span class="nx">MyClass</span> <span class="nv">$myclass</span><span class="p">){</span>
        <span class="c1">//...</span>
    <span class="p">}</span>

<span class="cp">?&gt;</span><span class="x"></span>
</code></pre></div>
<hr>

<blockquote>
<p>PHP5.2</p>

<p>2006年 ~ 2011年</p>
</blockquote>

<p><strong>JSON支持</strong></p>

<p>包括json<em>encode(), json</em>decode()等函数，JSON算是在web领域非常实用的数据交换格式，可以被JS直接支持，JSON实际上JS语法的一部分。</p>

<p>JSON系列函数，可以将PHP中的数组结构与JSON字符串进行转换。</p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>

    <span class="nv">$arr</span> <span class="o">=</span> <span class="k">array</span><span class="p">(</span>
        <span class="s2">&quot;key&quot;</span>   <span class="o">=&gt;</span>  <span class="s2">&quot;value&quot;</span><span class="p">,</span>
        <span class="s2">&quot;array&quot;</span> <span class="o">=&gt;</span>  <span class="k">array</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
    <span class="p">);</span>

    <span class="nv">$json</span> <span class="o">=</span> <span class="nb">json_encode</span><span class="p">(</span><span class="nv">$arr</span><span class="p">);</span>

    <span class="k">echo</span> <span class="nv">$json</span><span class="p">;</span>

    <span class="nv">$object</span> <span class="o">=</span> <span class="nb">json_decode</span><span class="p">(</span><span class="nv">$json</span><span class="p">);</span>   

    <span class="nb">print_r</span><span class="p">(</span><span class="nv">$object</span><span class="p">);</span>
<span class="cp">?&gt;</span><span class="x"></span>
</code></pre></div>
<p>输出：</p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="x">    {&quot;key&quot;:&quot;value&quot;,&quot;array&quot;:[1,2,3,4]}</span>

<span class="x">    stdClass Object</span>
<span class="x">    (</span>
<span class="x">        [key] =&gt; value</span>
<span class="x">        [array] =&gt; Array</span>
<span class="x">            (</span>
<span class="x">                [0] =&gt; 1</span>
<span class="x">                [1] =&gt; 2</span>
<span class="x">                [2] =&gt; 3</span>
<span class="x">                [3] =&gt; 4</span>
<span class="x">            )</span>
<span class="x">    )</span>
</code></pre></div>
<p>值得注意的是，json<em>decode()默认会返回一个对象而非数组，如果需要返回数组需要将第二个参数设为true。同时json</em>encode()在php5.4的时候增加了一个<strong>JSON_UNESCAPED_UNICODE</strong>的常量，这样，如果键值对中包含中文就不会被编码成unicode字符了。</p>

<hr>

<blockquote>
<p>PHP5.3</p>

<p>2009年 ~ 2012年 PHP5.3算是一个非常大的更新 ，新增了大量的新特性，同时也做了一些不向下兼容的修改。</p>
</blockquote>

<p><strong>弃用的功能</strong></p>

<p>以下几个功能被弃用，若在配置文件中启用，则PHP在运行时会发出警告。</p>

<ul>
<li>Register Globals</li>
</ul>

<p>这是php.ini中的一个选项(register_globals)，开启后会将所有表单变量($_GET 和 $_POST）注册为全局变量。</p>

<p>看下面的例子：</p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>

    <span class="k">if</span> <span class="p">(</span> <span class="nx">isAuth</span><span class="p">()</span> <span class="p">){</span>
        <span class="nv">$autherize</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="nv">$autherize</span><span class="p">){</span>
        <span class="k">include</span><span class="p">(</span><span class="s2">&quot;page.php&quot;</span><span class="p">);</span>
    <span class="p">}</span>

<span class="cp">?&gt;</span><span class="x"></span>
</code></pre></div>
<p>这段代码在通过验证时，将$autherize设为true，然后根据$autherize的值来决定是否显示页面。</p>

<p>但由于没有事先把$authorize初始化为false，当register_globals打开时，可能访问/auth.php?authorize=1来定义该变量值，绕过身份验证。</p>

<p>该特征属于历史遗留原因，在PHP4.2中默认被关闭，在PHP5.4中被移除。</p>

<ul>
<li>Magic Quotes</li>
</ul>

<p>对应php.ini中的选项 magic<em>quotes</em>gpc，这个特征同样属于历史遗留原因，已经在PHP5.4移除。</p>

<p>该特征会对所有用户输入的 ‘ (单引号)，“ (双引号)，\(反斜线) 进行转义，和addslashes()作用完全一样，这看上去不错，但是PHP并不知道哪些输入会进SQL，哪些输入会进Shell，哪些输入会被显示为HTML，所以很多时候这种转义会引起混乱。</p>

<p>PHP一共有三个魔术引号指令：</p>

<p>magic_quotes_gpc：影响HTTP请求数据(GET, POST和COOKIE)，不能在运行时改变，在PHP中默认值为On。( 相关函数：get_magic_quotes_gpc() )</p>

<p>magic_quotes_runtime：如果打开的话，大部分从外部来源取得数据并返回的函数，包括从数据库和文件，所返回的数据都会被转义。该选项可在运行时改变，在PHP中默认值为Off。( 相关函数：get_magic_quotes_runtime()，set_magic_quotes_runtime() )</p>

<p>magic_quotes_sybase：如果打开的话，将会使用单引号对单引号进行转义而不是反斜线。此选项会完全覆盖magic_quote_gpc。( 获取该选项的值通过ini_get()函数 )</p>

<ul>
<li>Safe Model</li>
</ul>

<p>很多虚拟主机提供商使用Safe Mode 来隔离多个用户，但Safe Model存在诸多问题，例如有些扩展并不按照Safe Mode来进行控制。</p>

<p>PHP官方推荐使用操作系统的机制来进行权限隔离，让Web服务器以不同的用户权限来运行PHP解释器。</p>

<p><strong>匿名函数</strong></p>

<p>匿名函数也叫闭包(Closures)，经常被用来临时性的创建一个无名函数，用于回调函数等用途。</p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>

    <span class="nv">$func</span> <span class="o">=</span> <span class="k">function</span><span class="p">(){</span>
        <span class="nb">var_dump</span><span class="p">(</span><span class="nb">func_get_args</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="nv">$func</span><span class="p">(</span><span class="s2">&quot;Hello&quot;</span><span class="p">,</span><span class="s2">&quot;world&quot;</span><span class="p">);</span>
<span class="cp">?&gt;</span><span class="x"></span>
</code></pre></div>
<p>以上代码定义了一个匿名函数，并赋值给了func。</p>

<p>可以看到定义匿名函数依然使用function关键字，只不过省略了函数名，直接是参数列表。</p>

<p>然后我们又调用了$func所储存的匿名函数。</p>

<p>匿名函数还可以通过use关键字来捕捉外部变量。</p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>

    <span class="k">function</span> <span class="nf">ArrayPlus</span><span class="p">(</span><span class="nv">$array</span><span class="p">,</span> <span class="nv">$num</span><span class="p">){</span>

        <span class="nb">array_walk</span><span class="p">(</span><span class="nv">$array</span><span class="p">,</span> <span class="k">function</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">$v</span><span class="p">)</span> <span class="k">use</span><span class="p">(</span><span class="nv">$num</span><span class="p">){</span>
            <span class="nv">$v</span> <span class="o">*=</span> <span class="nv">$num</span><span class="p">;</span>
        <span class="p">});</span>

        <span class="k">return</span> <span class="nv">$array</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nb">var_dump</span><span class="p">(</span><span class="nx">ArrayPlus</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="mi">6</span><span class="p">));</span>
<span class="cp">?&gt;</span><span class="x"></span>
</code></pre></div>
<p>上面的代码定义了一个ArrayPlus()函数（这不是匿名函数），它会将一个数组（$array）中的每一项，加上一个指定的数字（$num）。</p>

<p>在ArrayPlus()的实现中，我们使用了array_walk()函数，它会为一个数组的每一项执行一个回调函数，即我们定义的匿名函数。</p>

<p>在匿名函数的参数列表后，我们用use关键字将匿名函数外的$num捕捉到了函数内部，以便我们知道该加多少。</p>

<p><strong>魔术方法: __invoke(), __callStatic()</strong></p>

<p>PHP的面向对象体系中，提供了若干“魔术方法”，用于实现类似其它语言中的“重载”，如访问不存在的方法、属性时触发某个魔术方法。</p>

<p>随着匿名函数的加入，PHP引入了一个新的魔术方法__invoke()。</p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>

    <span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>

        <span class="k">public</span> <span class="k">function</span> <span class="nf">__invoke</span><span class="p">(</span><span class="nv">$str</span><span class="p">){</span>
            <span class="k">echo</span> <span class="s2">&quot;A::__invoke:</span><span class="si">{</span><span class="nv">$str</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nv">$a</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">A</span><span class="p">();</span>

    <span class="nv">$a</span><span class="p">(</span><span class="s2">&quot;jaylee.cc&quot;</span><span class="p">);</span>    <span class="c1">//A::__invoke:jaylee.cc</span>
<span class="cp">?&gt;</span><span class="x"></span>
</code></pre></div>
<p>__callStatic()则会在调用一个不存在的静态方法时被调用。</p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="x">    </span><span class="cp">&lt;?php</span>

    <span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>

        <span class="k">public</span> <span class="k">function</span> <span class="nf">__callStatic</span><span class="p">(</span><span class="nv">$methodName</span><span class="p">,</span> <span class="nv">$args</span><span class="p">){</span>
            <span class="nb">var_dump</span><span class="p">(</span><span class="nv">$methodName</span><span class="p">,</span> <span class="nv">$args</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nx">A</span><span class="o">::</span><span class="na">test</span><span class="p">(</span><span class="s2">&quot;aa&quot;</span><span class="p">,</span><span class="s2">&quot;bb&quot;</span><span class="p">);</span>

<span class="cp">?&gt;</span><span class="x"></span>
</code></pre></div>
<p><strong>命名空间</strong></p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>

    <span class="c1">// 命名空间的分隔符是反斜杠，该声明语句必须在文件第一行。</span>
    <span class="c1">// 命名空间中可以包含任意代码，但只有类，函数，常量受命名空间的影响</span>

    <span class="k">namespace</span> <span class="nx">Jaylee\Test</span><span class="p">;</span>

    <span class="c1">// 该类的完整限定名是\Jaylee\Test\A，其中第一个反斜杠表示全局命名空间</span>
    <span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
        <span class="k">public</span> <span class="k">function</span> <span class="nf">test</span><span class="p">(){</span>
            <span class="k">echo</span> <span class="s2">&quot;namespace:&quot;</span><span class="o">.</span><span class="nx">__NAMESPACE__</span><span class="o">.</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="nx">__CLASS__</span><span class="o">.</span><span class="s2">&quot;&lt;br /&gt;&quot;</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 你还可以在命名空间中定义第二个命名空间，接下来的代码都位于\Other\Test2</span>
    <span class="k">namespace</span> <span class="nx">Other\Test2</span><span class="p">;</span>

    <span class="c1">// 实例化来自其它命名空间中的对象</span>
    <span class="nv">$a</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">\Jaylee\Test\A</span><span class="p">;</span>

    <span class="k">class</span> <span class="nc">B</span> <span class="p">{</span>
        <span class="k">public</span> <span class="k">function</span> <span class="nf">test</span><span class="p">(){</span>
            <span class="k">echo</span> <span class="s2">&quot;namespace:&quot;</span><span class="o">.</span><span class="nx">__NAMESPACE__</span><span class="o">.</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="nx">__CLASS__</span><span class="o">.</span><span class="s2">&quot;&lt;br /&gt;&quot;</span><span class="p">;</span>        
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">namespace</span> <span class="nx">Other</span><span class="p">;</span>

    <span class="c1">// 实例化来自子命名空间的对象        </span>
    <span class="nv">$b</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Test2\B</span><span class="p">;</span>

    <span class="nv">$b</span><span class="o">-&gt;</span><span class="na">test</span><span class="p">();</span>

    <span class="c1">// 导入来自其它命名空间的名称，并重命名</span>
    <span class="c1">// 注意只能导入类，不能用于函数和常量</span>
    <span class="k">use</span> <span class="nx">\Jaylee\Test\A</span> <span class="k">as</span> <span class="nx">ClassA</span><span class="p">;</span>

    <span class="nv">$a</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ClassA</span><span class="p">();</span>

    <span class="nv">$a</span><span class="o">-&gt;</span><span class="na">test</span><span class="p">();</span>    
<span class="cp">?&gt;</span><span class="x"></span>
</code></pre></div>
<p>更多有关命名空间的语法介绍请参见<a href="http://php.net/manual/zh/language.namespaces.rationale.php">官网</a>。</p>

<p>命名空间经常和autoload一起使用，用于自动加载类文件：</p>
<div class="highlight"><pre><code class="language-php" data-lang="php"><span class="cp">&lt;?php</span>

    <span class="nb">spl_autoload_register</span><span class="p">(</span>
        <span class="k">function</span><span class="p">(</span><span class="nv">$className</span><span class="p">){</span>
            <span class="nb">spl_autoload</span><span class="p">(</span><span class="nb">str_replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;/&quot;</span><span class="p">,</span> <span class="nv">$className</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">);</span>
<span class="cp">?&gt;</span><span class="x"></span>
</code></pre></div>
<p>当你实例化一个类\Jaylee\Test\TestA的时候，这个类的完整限定名称会被传递给autoload函数，autoload函数将类名中的命名空间分隔符替换为反斜杠，并包含对应文件。</p>

<p>这样可以实现类定义文件分组存储，按需自动加载。</p>

				</section>
			</div>

			
				<!-- 多说评论框 start -->
<div class="block ds-thread" data-title="PHP5.2自5.6新特性" data-url="http://www.jaylee.cc/php5-2-since-new-in-5-6/"></div>
<!-- 多说评论框 end -->
			

		</div>

		<script>

            jQuery(document).ready(function($) {

                App.mapKeySupport();

                App.initNProgress();

                App.initDuoshuo();
            });

		</script>

	</body>

	<footer>
  <span class="muted">© Jaylee. All Rights Reserved.</span><br>
  <a href="http://github.com/chloerei/scribble" class="muted">built with Jekyll using Scribble theme</a>
  <br>
  <br>
  <!--img src="/images/scribble2.png" alt="scribble" /-->
</footer>


</html>
